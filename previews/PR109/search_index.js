var documenterSearchIndex = {"docs":
[{"location":"turing/#Turing-Example","page":"Using with Turing","title":"Turing Example","text":"","category":"section"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"This example demonstrates how to correctly compute PSIS LOO for a model developed with Turing.jl. Below, we show two ways to correctly specify the model in Turing. What is most important is to specify the model so that pointwise log densities are computed for each observation. ","category":"page"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"To make things simple, we will use a Gaussian model in each example. Suppose observations Y = y_1y_2dots y_n come from a Gaussian distribution with an uknown parameter mu and known parameter sigma=1. The model can be stated as follows:","category":"page"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"mu sim mathrmnormal(0 1)","category":"page"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"Y sim mathrmNormal(mu 1)","category":"page"},{"location":"turing/#For-Loop-Method","page":"Using with Turing","title":"For Loop Method","text":"","category":"section"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"One way to specify a model to correctly compute PSIS LOO is to iterate over the observations using a for loop, as follows:","category":"page"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"using Turing\nusing ParetoSmooth\nusing Distributions\nusing Random\n\nRandom.seed!(5)\n\n@model function model(data)\n    μ ~ Normal()\n    for i in 1:length(data)\n        data[i] ~ Normal(μ, 1)\n    end\nend\n\ndata = rand(Normal(0, 1), 100)\n\nchain = sample(model(data), NUTS(), 1000)\npsis_loo(model(data), chain)","category":"page"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"The output below correctly indicates PSIS LOO was computed with 100 data points. ","category":"page"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"[ Info: No source provided for samples; variables are assumed to be from a Markov Chain. If the samples are independent, specify this with keyword argument `source=:other`.\nResults of PSIS-LOO-CV with 1000 Monte Carlo samples and 100 data points. Total Monte Carlo SE of 0.064.\n┌───────────┬─────────┬──────────┬───────┬─────────┐\n│           │   total │ se_total │  mean │ se_mean │\n├───────────┼─────────┼──────────┼───────┼─────────┤\n│   cv_elpd │ -158.82 │     9.24 │ -1.59 │    0.09 │\n│ naive_lpd │ -157.43 │     9.05 │ -1.57 │    0.09 │\n│     p_eff │    1.39 │     0.19 │  0.01 │    0.00 │\n└───────────┴─────────┴──────────┴───────┴─────────┘","category":"page"},{"location":"turing/#Dot-Vectorization-Method","page":"Using with Turing","title":"Dot Vectorization Method","text":"","category":"section"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"The other method uses dot vectorization in the sampling statement: .~. Adapting the model above accordingly, we have:","category":"page"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"using Turing\nusing ParetoSmooth\nusing Distributions\nusing Random\n\nRandom.seed!(5)\n\n@model function model(data)\n    μ ~ Normal()\n    data .~ Normal(μ, 1)\nend\n\ndata = rand(Normal(0, 1), 100)\n\nchain = sample(model(data), NUTS(), 1000)\npsis_loo(model(data), chain)","category":"page"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"As before, the output correctly indicates PSIS LOO was computed with 100 observations. ","category":"page"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"[ Info: No source provided for samples; variables are assumed to be from a Markov Chain. If the samples are independent, specify this with keyword argument `source=:other`.\nResults of PSIS-LOO-CV with 1000 Monte Carlo samples and 100 data points. Total Monte Carlo SE of 0.053.\n┌───────────┬─────────┬──────────┬───────┬─────────┐\n│           │   total │ se_total │  mean │ se_mean │\n├───────────┼─────────┼──────────┼───────┼─────────┤\n│   cv_elpd │ -158.71 │     9.23 │ -1.59 │    0.09 │\n│ naive_lpd │ -157.44 │     9.06 │ -1.57 │    0.09 │\n│     p_eff │    1.27 │     0.18 │  0.01 │    0.00 │\n└───────────┴─────────┴──────────┴───────┴─────────┘","category":"page"},{"location":"turing/#Incorrect-Model-Specification","page":"Using with Turing","title":"Incorrect Model Specification","text":"","category":"section"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"Although the model below is valid, it will not produce the correct results for PSIS LOO because it computes a single log likelihood for the data rather than one for each observation. Note the lack of . in the sampling statement.","category":"page"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"using Turing\nusing ParetoSmooth\nusing Distributions\nusing Random\n\nRandom.seed!(5)\n\n@model function model(data)\n    μ ~ Normal()\n    data ~ Normal(μ, 1)\nend\n\ndata = rand(Normal(0, 1), 100)\n\nchain = sample(model(data), NUTS(), 1000)\npsis_loo(model(data), chain)","category":"page"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"In this case, there is only 1 data point and the standard errors cannot be computed:","category":"page"},{"location":"turing/","page":"Using with Turing","title":"Using with Turing","text":"[ Info: No source provided for samples; variables are assumed to be from a Markov Chain. If the samples are independent, specify this with keyword argument `source=:other`.\n┌ Warning: Some Pareto k values are high (>.7), indicating PSIS has failed to approximate the true distribution.\n└ @ ParetoSmooth ~/.julia/packages/ParetoSmooth/AJM3j/src/InternalHelpers.jl:46\nResults of PSIS-LOO-CV with 1000 Monte Carlo samples and 1 data points. Total Monte Carlo SE of 0.15.\n┌───────────┬─────────┬──────────┬─────────┬─────────┐\n│           │   total │ se_total │    mean │ se_mean │\n├───────────┼─────────┼──────────┼─────────┼─────────┤\n│   cv_elpd │ -158.57 │      NaN │ -158.57 │     NaN │\n│ naive_lpd │ -157.91 │      NaN │ -157.91 │     NaN │\n│     p_eff │    0.66 │      NaN │    0.66 │     NaN │\n└───────────┴─────────┴──────────┴─────────┴─────────┘","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ParetoSmooth","category":"page"},{"location":"#ParetoSmooth","page":"Home","title":"ParetoSmooth","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ParetoSmooth.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ParetoSmooth]\nPrivate = false","category":"page"},{"location":"#ParetoSmooth.ModelComparison","page":"Home","title":"ParetoSmooth.ModelComparison","text":"ModelComparison\n\nA struct containing the results of model comparison.\n\nFields\n\npointwise::KeyedArray: A KeyedArray of pointwise estimates. See [PsisLoo]@ref.\nestimates::KeyedArray: A table containing the results of model comparison, with the following columns –\ncv_elpd: The difference in total leave-one-out cross validation scores between models.\ncv_avg: The difference in average LOO-CV scores between models.\nweight: A set of Akaike-like weights assigned to each model, which can be used in pseudo-Bayesian model averaging.\nstd_err::NamedTuple: A named tuple containing the standard error of cv_elpd. Note  that these estimators (incorrectly) assume all folds are independent, despite their  substantial overlap, which creates a downward biased estimator. LOO-CV differences are not asymptotically normal, so these standard errors cannot be used to  calculate a confidence interval.\ngmpd::NamedTuple: The geometric mean of the predictive distribution. It equals the  geometric mean of the probability assigned to each data point by the model, that is, exp(cv_avg). This measure is only meaningful for classifiers (variables with discrete  outcomes). We can think of it as measuring how often the model was right: A model that always predicts incorrectly will have a GMPD of 0, while a model that always predicts correctly will have a GMPD of 1. However, the GMPD gives a model \"Partial points\"  between 0 and 1 whenever the model assigns a probability other than 0 or 1 to the  outcome that actually happened.\n\nSee also: PsisLoo\n\n\n\n\n\n","category":"type"},{"location":"#ParetoSmooth.Psis","page":"Home","title":"ParetoSmooth.Psis","text":"Psis{R<:Real, AT<:AbstractArray{R, 3}, VT<:AbstractVector{R}}\n\nA struct containing the results of Pareto-smoothed importance sampling.\n\nFields\n\nweights: A vector of smoothed, truncated, and normalized importance sampling weights.\npareto_k: Estimates of the shape parameter k of the generalized Pareto distribution.\ness: Estimated effective sample size for each LOO evaluation, based on the variance of the weights.\nsup_ess: Estimated effective sample size for each LOO evaluation, based on the  supremum norm, i.e. the size of the largest weight. More likely than ess to warn when  importance sampling has failed. However, it can have a high variance.\nr_eff: The relative efficiency of the MCMC chain, i.e. ESS / posterior sample size.\ntail_len: Vector indicating how large the \"tail\" is for each observation.\nposterior_sample_size: How many draws from an MCMC chain were used for PSIS.\ndata_size: How many data points were used for PSIS.\n\n\n\n\n\n","category":"type"},{"location":"#ParetoSmooth.PsisLoo","page":"Home","title":"ParetoSmooth.PsisLoo","text":"PsisLoo <: AbstractCV\n\nA struct containing the results of leave-one-out cross validation computed with Pareto  smoothed importance sampling.\n\nFields\n\nestimates::KeyedArray: A KeyedArray with columns :total, :se_total, :mean, :se_mean, and rows :cv_elpd, :naive_lpd, :p_eff. See # Extended help for more.\n:cv_elpd contains estimates for the out-of-sample prediction error, as estimated using leave-one-out cross validation.\n:naive_lpd contains estimates of the in-sample prediction error.\n:p_eff is the effective number of parameters – a model with a p_eff of 2 is  \"about as overfit\" as a model with 2 parameters and no regularization.\npointwise::KeyedArray: A KeyedArray of pointwise estimates with 5 columns –\n:cv_elpd contains the estimated out-of-sample error for this point, as measured\nusing leave-one-out cross validation.\n:naive_lpd contains the in-sample estimate of error for this point.\n:p_eff is the difference in the two previous estimates.\n:ess is the L2 effective sample size, which estimates the simulation error caused  by using Monte Carlo estimates. It does not measure model performance.  \n:inf_ess is the supremum-based effective sample size, which estimates the  simulation error caused by using Monte Carlo estimates. It is more robust than  :ess and should therefore be preferred. It does not measure model performance.  \n:pareto_k is the estimated value for the parameter ξ of the generalized Pareto distribution. Values above .7 indicate that PSIS has failed to approximate the true distribution.\npsis_object::Psis: A Psis object containing the results of Pareto-smoothed  importance sampling.\ngmpd: The geometric mean of the predictive density. It is defined as the geometric mean of the probability assigned to each data point by the model, i.e. exp(cv_avg).  This measure is only interpretable for classifiers (variables with discrete outcomes). We can think of it as measuring how often the model was right: A model that always predicts incorrectly will have a GMPD of 0, while a model that always predicts correctly will have a GMPD of 1. However, the GMPD gives a model \"Partial points\"  between 0 and 1 whenever the model assigns a probability other than 0 or 1 to the  outcome that actually happened, making it a fully Bayesian measure of model quality.\nmcse: A float containing the estimated Monte Carlo standard error for the total  cross-validation estimate.\n\nExtended help\n\nThe total score depends on the sample size, and summarizes the weight of evidence for or against a model. Total scores are on an interval scale, meaning that only differences of scores are meaningful. It is not possible to interpret a total score by looking at it. The total score is not a goodness-of-fit statistic (for this, see the average score).\n\nThe average score is the total score, divided by the sample size. It estimates the expected log score, i.e. the expectation of the log probability density of observing the next point. The average score is a relative goodness-of-fit statistic which does not depend on sample size. \n\nUnlike for chi-square goodness of fit tests, models do not have to be nested for model comparison using cross-validation methods.\n\nSee also: [loo]@ref, [bayes_cv]@ref, [psis_loo]@ref, [Psis]@ref\n\n\n\n\n\n","category":"type"},{"location":"#ParetoSmooth.loo-Tuple","page":"Home","title":"ParetoSmooth.loo","text":"function loo(args...; kwargs...) -> PsisLoo\n\nCompute an approximate leave-one-out cross-validation score.\n\nCurrently, this function only serves to call psis_loo, but this could change in the future. The default methods or return type may change without warning, so we recommend using psis_loo instead if reproducibility is required.\n\nSee also: psis_loo, PsisLoo.\n\n\n\n\n\n","category":"method"},{"location":"#ParetoSmooth.loo_compare-Union{Tuple{AbstractVector{<:PsisLoo}}, Tuple{S}} where S<:(Union{Tuple{Vararg{var\"#s41\"}}, AbstractVector{<:var\"#s41\"}} where var\"#s41\"<:Union{AbstractString, Symbol})","page":"Home","title":"ParetoSmooth.loo_compare","text":"function loo_compare(\n    cv_results...;\n    sort_models::Bool=true,\n    best_to_worst::Bool=true,\n    [, model_names::Tuple{Symbol}]\n) -> ModelComparison\n\nConstruct a model comparison table from several PsisLoo objects.\n\nArguments\n\ncv_results: One or more PsisLoo objects to be compared. Alternatively, a tuple or named tuple of PsisLoo objects can be passed. If a named tuple is passed, these names will be used to label each model. \nmodel_names: A vector or tuple of strings or symbols used to identify models. If none, models are numbered using the order of the arguments.\nsort_models: Sort models by total score.\nhigh_to_low: Sort models from best to worst score. If false, reverse the order.\n\nSee also: ModelComparison, PsisLoo, psis_loo\n\n\n\n\n\n","category":"method"},{"location":"#ParetoSmooth.loo_from_psis-Tuple{AbstractArray{<:Real, 3}, Psis}","page":"Home","title":"ParetoSmooth.loo_from_psis","text":"loo_from_psis(\n    log_likelihood::AbstractArray{<:Real}, psis_object::Psis; \n    chain_index::Vector{<:Integer}\n)\n\nUse a precalculated Psis object to estimate the leave-one-out cross validation score.\n\nArguments\n\nlog_likelihood::Array: A matrix or 3d array of log-likelihood values indexed as\n\n[data, step, chain]. The chain argument can be left off if chain_index is provided or if all posterior samples were drawn from a single chain.\n\npsis_object: A precomputed Psis object used to estimate the LOO-CV score.\nchain_index::Vector{Int}: An optional vector of integers specifying which chain each step\n\nbelongs to. For instance, chain_index[step] should return 2 if log_likelihood[:, step] belongs to the second chain.\n\nSee also: psis, loo, PsisLoo.\n\n\n\n\n\n","category":"method"},{"location":"#ParetoSmooth.pointwise_log_likelihoods-Tuple{Function, AbstractArray{<:Union{Missing, Real}, 3}, Any}","page":"Home","title":"ParetoSmooth.pointwise_log_likelihoods","text":"pointwise_log_likelihoods(\n    ll_fun::Function, samples::AbstractArray{<:Real,3}, data;\n    splat::Bool=true[, chain_index::Vector{<:Integer}]\n)\n\nCompute the pointwise log likelihoods.\n\nArguments\n\nll_fun::Function: A function taking a single data point and returning the log-likelihood\n\nof that point. This function must take the form f(θ[1], ..., θ[n], data), where θ is the parameter vector. See also the splat keyword argument.\n\nsamples::AbstractArray: A three dimensional array of MCMC samples. Here, the first dimension should indicate the step of the MCMC algorithm; the second dimension should indicate the parameter; and the third should indicate the chain. \ndata: An array of data points used to estimate the parameters of the model.\nsplat: If true (default), f must be a function of n different parameters.  Otherwise, f is assumed to be a function of a single parameter vector.\nchain_index::Vector{Int}: An optional vector of integers specifying which chain each step\n\nbelongs to. For instance, chain_index[step] should return 2 if log_likelihood[:, step] belongs to the second chain.\n\nReturns\n\nArray: A three dimensional array of pointwise log-likelihoods.\n\n\n\n\n\n","category":"method"},{"location":"#ParetoSmooth.psis!-Union{Tuple{AbstractVector{T}}, Tuple{T}, Tuple{AbstractVector{T}, T}} where T<:Real","page":"Home","title":"ParetoSmooth.psis!","text":"psis!(\n    is_ratios::AbstractVector{<:Real}; \n    tail_length::Integer, log_weights::Bool=true\n) -> Real\n\nDo PSIS on a single vector, smoothing its tail values in place before returning the  estimated shape constant for the pareto_k distribution. This does not normalize the  log-weights.\n\nArguments\n\nis_ratios::AbstractVector{<:Real}: A vector of importance sampling ratios, scaled to have a maximum of 1.\nr_eff::AbstractVector{<:Real}: The relative effective sample size, used to calculate the effective sample size. See [rel_eff]@ref for more information.\nlog_weights::Bool: A boolean indicating whether the input vector is a vector of log ratios, rather than raw importance sampling ratios.\n\nReturns\n\nReal: ξ, the shape parameter for the GPD. Bigger numbers indicate thicker tails.\n\nNotes\n\nUnlike the methods for arrays, psis! performs no checks to make sure the input values are  valid.\n\n\n\n\n\n","category":"method"},{"location":"#ParetoSmooth.psis-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T<:Real","page":"Home","title":"ParetoSmooth.psis","text":"psis(\n    log_ratios::AbstractArray{T<:Real}, \n    r_eff::AbstractVector{T}; \n    source::String=\"mcmc\"    \n) -> Psis\n\nImplements Pareto-smoothed importance sampling (PSIS).\n\nArguments\n\nPositional Arguments\n\nlog_ratios::AbstractArray: A 2d or 3d array of (unnormalized) importance ratios on the log scale. Indices must be ordered as [data, step, chain]. The chain index can be left  off if there is only one chain, or if keyword argument chain_index is provided.\nr_eff::AbstractVector: An (optional) vector of relative effective sample sizes used in ESS\n\ncalculations. If left empty, calculated automatically using the FFTESS method from InferenceDiagnostics.jl. See relative_eff to calculate these values.\n\nKeyword Arguments\n\nchain_index::Vector{Int}: An optional vector of integers specifying which chain each step\n\nbelongs to. For instance, chain_index[step] should return 2 if log_likelihood[:, step] belongs to the second chain.\n\nsource::String=\"mcmc\": A string or symbol describing the source of the sample being  used. If \"mcmc\", adjusts ESS for autocorrelation. Otherwise, samples are assumed to be  independent. Currently permitted values are [\"mcmc\", \"vi\", \"other\"].\ncalc_ess::Bool=true: If false, do not calculate ESS diagnostics. Attempting to access ESS diagnostics will return an empty array.\nchecks::Bool=true: If true, check inputs for possible errors. Disabling will improve  performance slightly.\n\nSee also: [relative_eff]@ref, [psis_loo]@ref, [psis_ess]@ref.\n\n\n\n\n\n","category":"method"},{"location":"#ParetoSmooth.psis_ess-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T<:Real","page":"Home","title":"ParetoSmooth.psis_ess","text":"function psis_ess(\n    weights::AbstractVector{T<:Real},\n    r_eff::AbstractVector{T}\n) -> AbstractVector{T}\n\nCalculate the (approximate) effective sample size of a PSIS sample, using the correction in Vehtari et al. 2019. This uses the entropy-based definition of ESS, measuring the K-L divergence of the proposal and target distributions.\n\nArguments\n\nweights: A set of normalized importance sampling weights derived from PSIS.\nr_eff: The relative efficiency of the MCMC chains from which PSIS samples were derived.\n\nSee ?relative_eff to calculate r_eff.\n\n\n\n\n\n","category":"method"},{"location":"#ParetoSmooth.psis_loo-Tuple{AbstractArray{<:Real, 3}, Vararg{Any}}","page":"Home","title":"ParetoSmooth.psis_loo","text":"function psis_loo(\n    log_likelihood::AbstractArray{<:Real} [, args...];\n    [, chain_index::Vector{Int}, kwargs...]\n) -> PsisLoo\n\nUse Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation score.\n\nArguments\n\nlog_likelihood::Array: A matrix or 3d array of log-likelihood values indexed as\n\n[data, step, chain]. The chain argument can be left off if chain_index is provided or if all posterior samples were drawn from a single chain.\n\nargs...: Positional arguments to be passed to psis.\nchain_index::Vector{Int}: An optional vector of integers specifying which chain each step\n\nbelongs to. For instance, chain_index[step] should return 2 if log_likelihood[:, step] belongs to the second chain.\n\nkwargs...: Keyword arguments to be passed to psis.\n\nSee also: psis, loo, PsisLoo.\n\n\n\n\n\n","category":"method"},{"location":"#ParetoSmooth.relative_eff-Tuple{AbstractArray{<:Real, 3}}","page":"Home","title":"ParetoSmooth.relative_eff","text":"relative_eff(\n    sample::AbstractArray{<:Real, 3};\n    source::Union{AbstractString, Symbol} = \"default\",\n    maxlag::Int = typemax(Int),\n    kwargs..., \n)\n\nCalculate the relative efficiency of an MCMC chain, i.e., the effective sample size divided by the nominal sample size.\n\nIf lowercase(String(source)) is \"default\" or \"mcmc\", the relative effective sample size is computed with MCMCDiagnosticTools.ess, using keyword arguments kind = :basic, maxlag = maxlag, and the remaining keyword arguments kwargs.... Otherwise a vector of ones for each chain is returned.\n\nArguments\n\nsample::AbstractArray{<:Real, 3}: An array of log-likelihood values of the shape (parameters, draws, chains).\n\n\n\n\n\n","category":"method"},{"location":"#ParetoSmooth.sup_ess-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T<:Real","page":"Home","title":"ParetoSmooth.sup_ess","text":"function sup_ess(\n    weights::AbstractMatrix{T},\n    r_eff::AbstractVector{T}\n) -> AbstractVector\n\nCalculate the supremum-based effective sample size of a PSIS sample, i.e. the inverse of the maximum weight. This measure is more sensitive than the ess from psis_ess, but also  much more variable. It uses the L-∞ norm.\n\nArguments\n\nweights: A set of importance sampling weights derived from PSIS.\nr_eff: The relative efficiency of the MCMC chains; see also [relative_eff]@ref.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"naive_lpd","category":"page"},{"location":"#ParetoSmooth.naive_lpd","page":"Home","title":"ParetoSmooth.naive_lpd","text":"naive_lpd(log_likelihood::AbstractArray{<:Real}[, chain_index])\n\nCalculate the naive (in-sample) estimate of the expected log probability density, otherwise known as the in-sample Bayes score. This method yields heavily biased results, and we advise against using it; it is included only for pedagogical purposes.\n\nThis method is unexported and can only be accessed by calling ParetoSmooth.naive_lpd.\n\nArguments\n\nlog_likelihood::Array: A matrix or 3d array of log-likelihood values indexed as\n\n[data, step, chain]. The chain argument can be left off if chain_index is provided or if all posterior samples were drawn from a single chain.\n\nchain_index::Vector{Int}: An optional vector of integers specifying which chain each step\n\nbelongs to. For instance, chain_index[step] should return 2 if log_likelihood[:, step] belongs to the second chain.\n\n\n\n\n\n","category":"function"}]
}
