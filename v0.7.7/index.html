<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ParetoSmooth.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://turinglang.github.io/ParetoSmooth.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ParetoSmooth.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="turing/">Using with Turing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ParetoSmooth"><a class="docs-heading-anchor" href="#ParetoSmooth">ParetoSmooth</a><a id="ParetoSmooth-1"></a><a class="docs-heading-anchor-permalink" href="#ParetoSmooth" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/TuringLang/ParetoSmooth.jl">ParetoSmooth</a>.</p><ul><li><a href="#ParetoSmooth.ModelComparison"><code>ParetoSmooth.ModelComparison</code></a></li><li><a href="#ParetoSmooth.Psis"><code>ParetoSmooth.Psis</code></a></li><li><a href="#ParetoSmooth.PsisLoo"><code>ParetoSmooth.PsisLoo</code></a></li><li><a href="#ParetoSmooth.loo-Tuple"><code>ParetoSmooth.loo</code></a></li><li><a href="#ParetoSmooth.loo_compare-Union{Tuple{AbstractVector{&lt;:PsisLoo}}, Tuple{S}} where S&lt;:(Union{Tuple{Vararg{var&quot;#s8&quot;}}, AbstractVector{&lt;:var&quot;#s8&quot;}} where var&quot;#s8&quot;&lt;:Union{AbstractString, Symbol})"><code>ParetoSmooth.loo_compare</code></a></li><li><a href="#ParetoSmooth.loo_from_psis-Tuple{AbstractArray{&lt;:Real, 3}, Psis}"><code>ParetoSmooth.loo_from_psis</code></a></li><li><a href="#ParetoSmooth.naive_lpd"><code>ParetoSmooth.naive_lpd</code></a></li><li><a href="#ParetoSmooth.pointwise_log_likelihoods-Tuple{Function, AbstractArray{&lt;:Union{Missing, Real}, 3}, Any}"><code>ParetoSmooth.pointwise_log_likelihoods</code></a></li><li><a href="#ParetoSmooth.psis-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:Real"><code>ParetoSmooth.psis</code></a></li><li><a href="#ParetoSmooth.psis!-Union{Tuple{AbstractVector{T}}, Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:Real"><code>ParetoSmooth.psis!</code></a></li><li><a href="#ParetoSmooth.psis_ess-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real"><code>ParetoSmooth.psis_ess</code></a></li><li><a href="#ParetoSmooth.psis_loo-Tuple{AbstractArray{&lt;:Real, 3}, Vararg{Any}}"><code>ParetoSmooth.psis_loo</code></a></li><li><a href="#ParetoSmooth.relative_eff-Tuple{AbstractArray{&lt;:Real, 3}}"><code>ParetoSmooth.relative_eff</code></a></li><li><a href="#ParetoSmooth.sup_ess-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real"><code>ParetoSmooth.sup_ess</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.ModelComparison" href="#ParetoSmooth.ModelComparison"><code>ParetoSmooth.ModelComparison</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelComparison</code></pre><p>A struct containing the results of model comparison.</p><p><strong>Fields</strong></p><ul><li><code>pointwise::KeyedArray</code>: A <code>KeyedArray</code> of pointwise estimates. See [<code>PsisLoo</code>]@ref.<ul><li><code>estimates::KeyedArray</code>: A table containing the results of model comparison, with the following columns –<ul><li><code>cv_elpd</code>: The difference in total leave-one-out cross validation scores between models.</li><li><code>cv_avg</code>: The difference in average LOO-CV scores between models.</li><li><code>weight</code>: A set of Akaike-like weights assigned to each model, which can be used in pseudo-Bayesian model averaging.</li></ul></li><li><code>std_err::NamedTuple</code>: A named tuple containing the standard error of <code>cv_elpd</code>. Note  that these estimators (incorrectly) assume all folds are independent, despite their  substantial overlap, which creates a downward biased estimator. LOO-CV differences are <em>not</em> asymptotically normal, so these standard errors cannot be used to  calculate a confidence interval.</li><li><code>gmpd::NamedTuple</code>: The geometric mean of the predictive distribution. It equals the  geometric mean of the probability assigned to each data point by the model, that is, <code>exp(cv_avg)</code>. This measure is only meaningful for classifiers (variables with discrete  outcomes). We can think of it as measuring how often the model was right: A model that always predicts incorrectly will have a GMPD of 0, while a model that always predicts correctly will have a GMPD of 1. However, the GMPD gives a model &quot;Partial points&quot;  between 0 and 1 whenever the model assigns a probability other than 0 or 1 to the  outcome that actually happened.</li></ul></li></ul><p>See also: <a href="#ParetoSmooth.PsisLoo"><code>PsisLoo</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/ModelComparison.jl#L6-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.Psis" href="#ParetoSmooth.Psis"><code>ParetoSmooth.Psis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Psis{R&lt;:Real, AT&lt;:AbstractArray{R, 3}, VT&lt;:AbstractVector{R}}</code></pre><p>A struct containing the results of Pareto-smoothed importance sampling.</p><p><strong>Fields</strong></p><ul><li><code>weights</code>: A vector of smoothed, truncated, and normalized importance sampling weights.</li><li><code>pareto_k</code>: Estimates of the shape parameter <code>k</code> of the generalized Pareto distribution.</li><li><code>ess</code>: Estimated effective sample size for each LOO evaluation, based on the variance of the weights.</li><li><code>sup_ess</code>: Estimated effective sample size for each LOO evaluation, based on the  supremum norm, i.e. the size of the largest weight. More likely than <code>ess</code> to warn when  importance sampling has failed. However, it can have a high variance.</li><li><code>r_eff</code>: The relative efficiency of the MCMC chain, i.e. ESS / posterior sample size.</li><li><code>tail_len</code>: Vector indicating how large the &quot;tail&quot; is for each observation.</li><li><code>posterior_sample_size</code>: How many draws from an MCMC chain were used for PSIS.</li><li><code>data_size</code>: How many data points were used for PSIS.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/ImportanceSampling.jl#L18-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.PsisLoo" href="#ParetoSmooth.PsisLoo"><code>ParetoSmooth.PsisLoo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PsisLoo &lt;: AbstractCV</code></pre><p>A struct containing the results of leave-one-out cross validation computed with Pareto  smoothed importance sampling.</p><p><strong>Fields</strong></p><ul><li><code>estimates::KeyedArray</code>: A KeyedArray with columns <code>:total, :se_total, :mean, :se_mean</code>, and rows <code>:cv_elpd, :naive_lpd, :p_eff</code>. See <code># Extended help</code> for more.<ul><li><code>:cv_elpd</code> contains estimates for the out-of-sample prediction error, as estimated using leave-one-out cross validation.</li><li><code>:naive_lpd</code> contains estimates of the in-sample prediction error.</li><li><code>:p_eff</code> is the effective number of parameters – a model with a <code>p_eff</code> of 2 is  &quot;about as overfit&quot; as a model with 2 parameters and no regularization.</li></ul></li><li><code>pointwise::KeyedArray</code>: A <code>KeyedArray</code> of pointwise estimates with 5 columns –<ul><li><code>:cv_elpd</code> contains the estimated out-of-sample error for this point, as measured</li></ul>using leave-one-out cross validation.<ul><li><code>:naive_lpd</code> contains the in-sample estimate of error for this point.</li><li><code>:p_eff</code> is the difference in the two previous estimates.</li><li><code>:ess</code> is the L2 effective sample size, which estimates the simulation error caused  by using Monte Carlo estimates. It does not measure model performance.  </li><li><code>:inf_ess</code> is the supremum-based effective sample size, which estimates the  simulation error caused by using Monte Carlo estimates. It is more robust than  <code>:ess</code> and should therefore be preferred. It does not measure model performance.  </li><li><code>:pareto_k</code> is the estimated value for the parameter <code>ξ</code> of the generalized Pareto distribution. Values above .7 indicate that PSIS has failed to approximate the true distribution.</li></ul></li><li><code>psis_object::Psis</code>: A <code>Psis</code> object containing the results of Pareto-smoothed  importance sampling.</li><li><code>gmpd</code>: The geometric mean of the predictive density. It is defined as the geometric mean of the probability assigned to each data point by the model, i.e. <code>exp(cv_avg)</code>.  This measure is only interpretable for classifiers (variables with discrete outcomes). We can think of it as measuring how often the model was right: A model that always predicts incorrectly will have a GMPD of 0, while a model that always predicts correctly will have a GMPD of 1. However, the GMPD gives a model &quot;Partial points&quot;  between 0 and 1 whenever the model assigns a probability other than 0 or 1 to the  outcome that actually happened, making it a fully Bayesian measure of model quality.</li><li><code>mcse</code>: A float containing the estimated Monte Carlo standard error for the total  cross-validation estimate.</li></ul><p><strong>Extended help</strong></p><p>The total score depends on the sample size, and summarizes the weight of evidence for or against a model. Total scores are on an interval scale, meaning that only differences of scores are meaningful. <em>It is not possible to interpret a total score by looking at it.</em> The total score is not a goodness-of-fit statistic (for this, see the average score).</p><p>The average score is the total score, divided by the sample size. It estimates the expected log score, i.e. the expectation of the log probability density of observing the next point. The average score is a relative goodness-of-fit statistic which does not depend on sample size. </p><p>Unlike for chi-square goodness of fit tests, models do not have to be nested for model comparison using cross-validation methods.</p><p>See also: [<code>loo</code>]@ref, [<code>bayes_cv</code>]@ref, [<code>psis_loo</code>]@ref, [<code>Psis</code>]@ref</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/LeaveOneOut.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.loo-Tuple" href="#ParetoSmooth.loo-Tuple"><code>ParetoSmooth.loo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function loo(args...; kwargs...) -&gt; PsisLoo</code></pre><p>Compute an approximate leave-one-out cross-validation score.</p><p>Currently, this function only serves to call <code>psis_loo</code>, but this could change in the future. The default methods or return type may change without warning, so we recommend using <code>psis_loo</code> instead if reproducibility is required.</p><p>See also: <a href="#ParetoSmooth.psis_loo-Tuple{AbstractArray{&lt;:Real, 3}, Vararg{Any}}"><code>psis_loo</code></a>, <a href="#ParetoSmooth.PsisLoo"><code>PsisLoo</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/LeaveOneOut.jl#L71-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.loo_compare-Union{Tuple{AbstractVector{&lt;:PsisLoo}}, Tuple{S}} where S&lt;:(Union{Tuple{Vararg{var&quot;#s8&quot;}}, AbstractVector{&lt;:var&quot;#s8&quot;}} where var&quot;#s8&quot;&lt;:Union{AbstractString, Symbol})" href="#ParetoSmooth.loo_compare-Union{Tuple{AbstractVector{&lt;:PsisLoo}}, Tuple{S}} where S&lt;:(Union{Tuple{Vararg{var&quot;#s8&quot;}}, AbstractVector{&lt;:var&quot;#s8&quot;}} where var&quot;#s8&quot;&lt;:Union{AbstractString, Symbol})"><code>ParetoSmooth.loo_compare</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function loo_compare(
    cv_results...;
    sort_models::Bool=true,
    best_to_worst::Bool=true,
    [, model_names::Tuple{Symbol}]
) -&gt; ModelComparison</code></pre><p>Construct a model comparison table from several <a href="#ParetoSmooth.PsisLoo"><code>PsisLoo</code></a> objects.</p><p><strong>Arguments</strong></p><ul><li><code>cv_results</code>: One or more <a href="#ParetoSmooth.PsisLoo"><code>PsisLoo</code></a> objects to be compared. Alternatively, a tuple or named tuple of <code>PsisLoo</code> objects can be passed. If a named tuple is passed, these names will be used to label each model. </li><li><code>model_names</code>: A vector or tuple of strings or symbols used to identify models. If none, models are numbered using the order of the arguments.</li><li><code>sort_models</code>: Sort models by total score.</li><li><code>high_to_low</code>: Sort models from best to worst score. If <code>false</code>, reverse the order.</li></ul><p>See also: <a href="#ParetoSmooth.ModelComparison"><code>ModelComparison</code></a>, <a href="#ParetoSmooth.PsisLoo"><code>PsisLoo</code></a>, <a href="#ParetoSmooth.psis_loo-Tuple{AbstractArray{&lt;:Real, 3}, Vararg{Any}}"><code>psis_loo</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/ModelComparison.jl#L46-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.loo_from_psis-Tuple{AbstractArray{&lt;:Real, 3}, Psis}" href="#ParetoSmooth.loo_from_psis-Tuple{AbstractArray{&lt;:Real, 3}, Psis}"><code>ParetoSmooth.loo_from_psis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loo_from_psis(
    log_likelihood::AbstractArray{&lt;:Real}, psis_object::Psis; 
    chain_index::Vector{&lt;:Integer}
)</code></pre><p>Use a precalculated <code>Psis</code> object to estimate the leave-one-out cross validation score.</p><p><strong>Arguments</strong></p><ul><li><code>log_likelihood::Array</code>: A matrix or 3d array of log-likelihood values indexed as</li></ul><p><code>[data, step, chain]</code>. The chain argument can be left off if <code>chain_index</code> is provided or if all posterior samples were drawn from a single chain.</p><ul><li><code>psis_object</code>: A precomputed <code>Psis</code> object used to estimate the LOO-CV score.</li><li><code>chain_index::Vector{Int}</code>: An optional vector of integers specifying which chain each step</li></ul><p>belongs to. For instance, <code>chain_index[step]</code> should return <code>2</code> if <code>log_likelihood[:, step]</code> belongs to the second chain.</p><p>See also: <a href="#ParetoSmooth.psis-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:Real"><code>psis</code></a>, <a href="#ParetoSmooth.loo-Tuple"><code>loo</code></a>, <a href="#ParetoSmooth.PsisLoo"><code>PsisLoo</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/LeaveOneOut.jl#L123-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.pointwise_log_likelihoods-Tuple{Function, AbstractArray{&lt;:Union{Missing, Real}, 3}, Any}" href="#ParetoSmooth.pointwise_log_likelihoods-Tuple{Function, AbstractArray{&lt;:Union{Missing, Real}, 3}, Any}"><code>ParetoSmooth.pointwise_log_likelihoods</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointwise_log_likelihoods(
    ll_fun::Function, samples::AbstractArray{&lt;:Real,3}, data;
    splat::Bool=true[, chain_index::Vector{&lt;:Integer}]
)</code></pre><p>Compute the pointwise log likelihoods.</p><p><strong>Arguments</strong></p><ul><li><code>ll_fun::Function</code>: A function taking a single data point and returning the log-likelihood</li></ul><p>of that point. This function must take the form <code>f(θ[1], ..., θ[n], data)</code>, where <code>θ</code> is the parameter vector. See also the <code>splat</code> keyword argument.</p><ul><li><p><code>samples::AbstractArray</code>: A three dimensional array of MCMC samples. Here, the first dimension should indicate the step of the MCMC algorithm; the second dimension should indicate the parameter; and the third should indicate the chain. </p></li><li><p><code>data</code>: An array of data points used to estimate the parameters of the model.</p></li><li><p><code>splat</code>: If <code>true</code> (default), <code>f</code> must be a function of <code>n</code> different parameters.  Otherwise, <code>f</code> is assumed to be a function of a single parameter vector.</p></li><li><p><code>chain_index::Vector{Int}</code>: An optional vector of integers specifying which chain each step</p></li></ul><p>belongs to. For instance, <code>chain_index[step]</code> should return <code>2</code> if <code>log_likelihood[:, step]</code> belongs to the second chain.</p><p><strong>Returns</strong></p><ul><li><code>Array</code>: A three dimensional array of pointwise log-likelihoods.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/PublicHelpers.jl#L10-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.psis!-Union{Tuple{AbstractVector{T}}, Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:Real" href="#ParetoSmooth.psis!-Union{Tuple{AbstractVector{T}}, Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:Real"><code>ParetoSmooth.psis!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">psis!(
    is_ratios::AbstractVector{&lt;:Real}; 
    tail_length::Integer, log_weights::Bool=true
) -&gt; Real</code></pre><p>Do PSIS on a single vector, smoothing its tail values <em>in place</em> before returning the  estimated shape constant for the <code>pareto_k</code> distribution. This <em>does not</em> normalize the  log-weights.</p><p><strong>Arguments</strong></p><ul><li><code>is_ratios::AbstractVector{&lt;:Real}</code>: A vector of importance sampling ratios, scaled to have a maximum of 1.</li><li><code>r_eff::AbstractVector{&lt;:Real}</code>: The relative effective sample size, used to calculate the effective sample size. See [rel_eff]@ref for more information.</li><li><code>log_weights::Bool</code>: A boolean indicating whether the input vector is a vector of log ratios, rather than raw importance sampling ratios.</li></ul><p><strong>Returns</strong></p><ul><li><code>Real</code>: ξ, the shape parameter for the GPD. Bigger numbers indicate thicker tails.</li></ul><p><strong>Notes</strong></p><p>Unlike the methods for arrays, <code>psis!</code> performs no checks to make sure the input values are  valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/ImportanceSampling.jl#L211-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.psis-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:Real" href="#ParetoSmooth.psis-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:Real"><code>ParetoSmooth.psis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">psis(
    log_ratios::AbstractArray{T&lt;:Real}, 
    r_eff::AbstractVector{T}; 
    source::String=&quot;mcmc&quot;    
) -&gt; Psis</code></pre><p>Implements Pareto-smoothed importance sampling (PSIS).</p><p><strong>Arguments</strong></p><p><strong>Positional Arguments</strong></p><ul><li><code>log_ratios::AbstractArray</code>: A 2d or 3d array of (unnormalized) importance ratios on the log scale. Indices must be ordered as <code>[data, step, chain]</code>. The chain index can be left  off if there is only one chain, or if keyword argument <code>chain_index</code> is provided.</li><li><code>r_eff::AbstractVector</code>: An (optional) vector of relative effective sample sizes used in ESS</li></ul><p>calculations. If left empty, calculated automatically using the FFTESS method from InferenceDiagnostics.jl. See <code>relative_eff</code> to calculate these values.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chain_index::Vector{Int}</code>: An optional vector of integers specifying which chain each step</li></ul><p>belongs to. For instance, <code>chain_index[step]</code> should return <code>2</code> if <code>log_likelihood[:, step]</code> belongs to the second chain.</p><ul><li><code>source::String=&quot;mcmc&quot;</code>: A string or symbol describing the source of the sample being  used. If <code>&quot;mcmc&quot;</code>, adjusts ESS for autocorrelation. Otherwise, samples are assumed to be  independent. Currently permitted values are [&quot;mcmc&quot;, &quot;vi&quot;, &quot;other&quot;].</li><li><code>calc_ess::Bool=true</code>: If <code>false</code>, do not calculate ESS diagnostics. Attempting to access ESS diagnostics will return an empty array.</li><li><code>checks::Bool=true</code>: If <code>true</code>, check inputs for possible errors. Disabling will improve  performance slightly.</li></ul><p>See also: [<code>relative_eff</code>]@ref, [<code>psis_loo</code>]@ref, [<code>psis_ess</code>]@ref.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/ImportanceSampling.jl#L92-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.psis_ess-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real" href="#ParetoSmooth.psis_ess-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real"><code>ParetoSmooth.psis_ess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function psis_ess(
    weights::AbstractVector{T&lt;:Real},
    r_eff::AbstractVector{T}
) -&gt; AbstractVector{T}</code></pre><p>Calculate the (approximate) effective sample size of a PSIS sample, using the correction in Vehtari et al. 2019. This uses the entropy-based definition of ESS, measuring the K-L divergence of the proposal and target distributions.</p><p><strong>Arguments</strong></p><ul><li><code>weights</code>: A set of normalized importance sampling weights derived from PSIS.</li><li><code>r_eff</code>: The relative efficiency of the MCMC chains from which PSIS samples were derived.</li></ul><p>See <code>?relative_eff</code> to calculate <code>r_eff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/ESS.jl#L40-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.psis_loo-Tuple{AbstractArray{&lt;:Real, 3}, Vararg{Any}}" href="#ParetoSmooth.psis_loo-Tuple{AbstractArray{&lt;:Real, 3}, Vararg{Any}}"><code>ParetoSmooth.psis_loo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function psis_loo(
    log_likelihood::AbstractArray{&lt;:Real} [, args...];
    [, chain_index::Vector{Int}, kwargs...]
) -&gt; PsisLoo</code></pre><p>Use Pareto-Smoothed Importance Sampling to calculate the leave-one-out cross validation score.</p><p><strong>Arguments</strong></p><ul><li><code>log_likelihood::Array</code>: A matrix or 3d array of log-likelihood values indexed as</li></ul><p><code>[data, step, chain]</code>. The chain argument can be left off if <code>chain_index</code> is provided or if all posterior samples were drawn from a single chain.</p><ul><li><code>args...</code>: Positional arguments to be passed to <a href="#ParetoSmooth.psis-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:Real"><code>psis</code></a>.</li><li><code>chain_index::Vector{Int}</code>: An optional vector of integers specifying which chain each step</li></ul><p>belongs to. For instance, <code>chain_index[step]</code> should return <code>2</code> if <code>log_likelihood[:, step]</code> belongs to the second chain.</p><ul><li><code>kwargs...</code>: Keyword arguments to be passed to <a href="#ParetoSmooth.psis-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:Real"><code>psis</code></a>.</li></ul><p>See also: <a href="#ParetoSmooth.psis-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:Real"><code>psis</code></a>, <a href="#ParetoSmooth.loo-Tuple"><code>loo</code></a>, <a href="#ParetoSmooth.PsisLoo"><code>PsisLoo</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/LeaveOneOut.jl#L87-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.relative_eff-Tuple{AbstractArray{&lt;:Real, 3}}" href="#ParetoSmooth.relative_eff-Tuple{AbstractArray{&lt;:Real, 3}}"><code>ParetoSmooth.relative_eff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_eff(
    sample::AbstractArray{&lt;:Real, 3};
    source::Union{AbstractString, Symbol} = &quot;default&quot;,
    maxlag::Int = typemax(Int),
    kwargs..., 
)</code></pre><p>Calculate the relative efficiency of an MCMC chain, i.e., the effective sample size divided by the nominal sample size.</p><p>If <code>lowercase(String(source))</code> is <code>&quot;default&quot;</code> or <code>&quot;mcmc&quot;</code>, the relative effective sample size is computed with <code>MCMCDiagnosticTools.ess</code>, using keyword arguments <code>kind = :basic</code>, <code>maxlag = maxlag</code>, and the remaining keyword arguments <code>kwargs...</code>. Otherwise a vector of ones for each chain is returned.</p><p><strong>Arguments</strong></p><ul><li><code>sample::AbstractArray{&lt;:Real, 3}</code>: An array of log-likelihood values of the shape <code>(parameters, draws, chains)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/ESS.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.sup_ess-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real" href="#ParetoSmooth.sup_ess-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real"><code>ParetoSmooth.sup_ess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sup_ess(
    weights::AbstractMatrix{T},
    r_eff::AbstractVector{T}
) -&gt; AbstractVector</code></pre><p>Calculate the supremum-based effective sample size of a PSIS sample, i.e. the inverse of the maximum weight. This measure is more sensitive than the <code>ess</code> from <code>psis_ess</code>, but also  much more variable. It uses the L-∞ norm.</p><p><strong>Arguments</strong></p><ul><li><code>weights</code>: A set of importance sampling weights derived from PSIS.</li><li><code>r_eff</code>: The relative efficiency of the MCMC chains; see also [<code>relative_eff</code>]@ref.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/ESS.jl#L78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParetoSmooth.naive_lpd" href="#ParetoSmooth.naive_lpd"><code>ParetoSmooth.naive_lpd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">naive_lpd(log_likelihood::AbstractArray{&lt;:Real}[, chain_index])</code></pre><p>Calculate the naive (in-sample) estimate of the expected log probability density, otherwise known as the in-sample Bayes score. This method yields heavily biased results, and we advise against using it; it is included only for pedagogical purposes.</p><p>This method is unexported and can only be accessed by calling <code>ParetoSmooth.naive_lpd</code>.</p><p><strong>Arguments</strong></p><ul><li><code>log_likelihood::Array</code>: A matrix or 3d array of log-likelihood values indexed as</li></ul><p><code>[data, step, chain]</code>. The chain argument can be left off if <code>chain_index</code> is provided or if all posterior samples were drawn from a single chain.</p><ul><li><code>chain_index::Vector{Int}</code>: An optional vector of integers specifying which chain each step</li></ul><p>belongs to. For instance, <code>chain_index[step]</code> should return <code>2</code> if <code>log_likelihood[:, step]</code> belongs to the second chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/ParetoSmooth.jl/blob/74a099d89ffee052aef1eee2841f54f1662843e4/src/NaiveLPD.jl#L1-L13">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="turing/">Using with Turing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 26 September 2023 23:55">Tuesday 26 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
