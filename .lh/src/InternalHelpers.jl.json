{
    "sourceFile": "src/InternalHelpers.jl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1626565928399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1626565951018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n \"\"\"\n Assume that all objects belong to a single chain if chain index is missing. Inform user.\n \"\"\"\n-function _assume_one_chain(matrix::AbstractMatrix)\n+function _assume_one_chain(matrix)\n     @info \"Chain information was not provided; \" *\n           \"all samples are assumed to be drawn from a single chain.\"\n-    return ones(length(matrix::AbstractMatrix))\n+    return ones(length(matrix))\n end\n \n \n \"\"\"\n"
                },
                {
                    "date": 1626566209767,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,12 +11,12 @@\n \"\"\"\n Convert a matrix+chain_index representation to a 3d array representation to pass it off to \n the method for arrays.\n \"\"\"\n-function _convert_to_array(log_ratios::AbstractMatrix, chain_index::AbstractVector)\n+function _convert_to_array(matrix::AbstractMatrix, chain_index::AbstractVector)\n     indices = unique(chain_index)\n     biggest_idx = maximum(indices)\n-    dims = size(log_ratios)\n+    dims = size(matrix)\n     if dims[2] ≠ length(chain_index)\n         throw(ArgumentError(\"Some entries do not have a chain index.\"))\n     elseif !issetequal(indices, 1:biggest_idx)\n         throw(\n@@ -31,10 +31,10 @@\n         if !all(==(counts[1]), counts)\n             throw(ArgumentError(\"All chains must be of equal length.\"))\n         end\n     end\n-    new_ratios = similar(log_ratios, dims[1], dims[2] ÷ biggest_idx, biggest_idx)\n+    new_ratios = similar(matrix, dims[1], dims[2] ÷ biggest_idx, biggest_idx)\n     for i in 1:biggest_idx\n-        new_ratios[:, :, i] .= log_ratios[:, chain_index .== i]\n+        new_ratios[:, :, i] .= matrix[:, chain_index .== i]\n     end\n     return new_ratios\n end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626574229040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,11 @@\n+const CHAIN_INDEX_DOC = \"\"\"\n+`chain_index::Vector`: An optional vector of integers specifying which chain each \n+    step belongs to. For instance, `chain_index[step]` should return `2` if\n+    `log_likelihood[:, step]` belongs to the second chain.\n \"\"\"\n+\n+\"\"\"\n Assume that all objects belong to a single chain if chain index is missing. Inform user.\n \"\"\"\n function _assume_one_chain(matrix)\n     @info \"Chain information was not provided; \" *\n@@ -8,10 +14,9 @@\n end\n \n \n \"\"\"\n-Convert a matrix+chain_index representation to a 3d array representation to pass it off to \n-the method for arrays.\n+Convert a matrix+chain_index representation to a 3d array representation.\n \"\"\"\n function _convert_to_array(matrix::AbstractMatrix, chain_index::AbstractVector)\n     indices = unique(chain_index)\n     biggest_idx = maximum(indices)\n"
                },
                {
                    "date": 1626622573360,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,20 @@\n     step belongs to. For instance, `chain_index[step]` should return `2` if\n     `log_likelihood[:, step]` belongs to the second chain.\n \"\"\"\n \n+const R_EFF_DOC = \"\"\"\n+`r_eff::AbstractArray{T}`: An (optional) vector of relative effective sample sizes used \n+in ESS calculations. If left empty, calculated automatically using the FFTESS method \n+from InferenceDiagnostics.jl. See `relative_eff` to calculate these values.\n \"\"\"\n+\n+\n+###############\n+## FUNCTIONS ##\n+###############\n+\n+\"\"\"\n Assume that all objects belong to a single chain if chain index is missing. Inform user.\n \"\"\"\n function _assume_one_chain(matrix)\n     @info \"Chain information was not provided; \" *\n"
                },
                {
                    "date": 1626622639345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,16 @@\n in ESS calculations. If left empty, calculated automatically using the FFTESS method \n from InferenceDiagnostics.jl. See `relative_eff` to calculate these values.\n \"\"\"\n \n+const ARGS = \"\"\"\n+`args...`: Positional arguments to be passed to\n+\"\"\"\n+const KWARGS = \"\"\"\n+`kwargs...`: Keyword arguments to be passed to\n+\"\"\"\n \n+\n ###############\n ## FUNCTIONS ##\n ###############\n \n"
                },
                {
                    "date": 1626631378386,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,14 @@\n     step belongs to. For instance, `chain_index[step]` should return `2` if\n     `log_likelihood[:, step]` belongs to the second chain.\n \"\"\"\n \n+const LIKELIHOOD_FUNCTION_ARG = \"\"\"\n+`ll_fun::Function`: A function taking a single data point and returning the log-likelihood \n+of that point. This function must take the form `f(θ[1], ..., θ[n], data)`, where `θ` is the\n+parameter vector. See also the `splat` keyword argument.\n+\"\"\"\n+\n const R_EFF_DOC = \"\"\"\n `r_eff::AbstractArray{T}`: An (optional) vector of relative effective sample sizes used \n in ESS calculations. If left empty, calculated automatically using the FFTESS method \n from InferenceDiagnostics.jl. See `relative_eff` to calculate these values.\n@@ -12,8 +18,9 @@\n \n const ARGS = \"\"\"\n `args...`: Positional arguments to be passed to\n \"\"\"\n+\n const KWARGS = \"\"\"\n `kwargs...`: Keyword arguments to be passed to\n \"\"\"\n \n"
                }
            ],
            "date": 1626565928399,
            "name": "Commit-0",
            "content": "\"\"\"\nAssume that all objects belong to a single chain if chain index is missing. Inform user.\n\"\"\"\nfunction _assume_one_chain(matrix::AbstractMatrix)\n    @info \"Chain information was not provided; \" *\n          \"all samples are assumed to be drawn from a single chain.\"\n    return ones(length(matrix::AbstractMatrix))\nend\n\n\n\"\"\"\nConvert a matrix+chain_index representation to a 3d array representation to pass it off to \nthe method for arrays.\n\"\"\"\nfunction _convert_to_array(log_ratios::AbstractMatrix, chain_index::AbstractVector)\n    indices = unique(chain_index)\n    biggest_idx = maximum(indices)\n    dims = size(log_ratios)\n    if dims[2] ≠ length(chain_index)\n        throw(ArgumentError(\"Some entries do not have a chain index.\"))\n    elseif !issetequal(indices, 1:biggest_idx)\n        throw(\n            ArgumentError(\n                \"Indices must be numbered from 1 through the total number of chains.\"\n            ),\n        )\n    else\n        # Check how many elements are in each chain, assign to \"counts\"\n        counts = count.(eachslice(chain_index .== indices'; dims=2))\n        # check if all inputs are the same length\n        if !all(==(counts[1]), counts)\n            throw(ArgumentError(\"All chains must be of equal length.\"))\n        end\n    end\n    new_ratios = similar(log_ratios, dims[1], dims[2] ÷ biggest_idx, biggest_idx)\n    for i in 1:biggest_idx\n        new_ratios[:, :, i] .= log_ratios[:, chain_index .== i]\n    end\n    return new_ratios\nend"
        }
    ]
}